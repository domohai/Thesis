\section{Verification of TOCL+ Properties}

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{figures/c2/Verification_approach_1.png}
    \caption{Verification approach.}
    \label{sec:verification_approach}
\end{figure}

\hspace{1cm} Figure \ref{sec:verification_approach} presents a comprehensive overview 
of our verification approach for TOCL+ properties. The process begins when a UML 
modeler creates an Application Model and specifies temporal properties using TOCL+. 
Our approach consists of three sequential transformation and verification steps:

First, we transform the Application Model into a Filmstrip Model. This crucial step 
converts dynamic specifications into static ones by representing the system's behavior 
through a sequence of snapshots and operation calls. The Filmstrip Model effectively 
flattens temporal behavior into a structural representation that can be analyzed 
using static verification techniques.

Second, we translate the TOCL+ properties into equivalent OCL expressions interpreted 
over the Filmstrip Model. These OCL expressions navigate through snapshots and 
operation calls, ensuring that the temporal constraints are properly enforced across 
the system's execution. The translation process systematically converts temporal 
operators and event constructs into path expressions over the filmstrip structure.

Third, we verify the resulting OCL expressions using the USE Model Validator 
\cite{USE_Validator}. This static analysis tool examines the Filmstrip Model against 
the translated constraints within a configurable search space defined in a properties 
file. The validator explores possible system states, reporting either SATISFIABLE 
(when a valid system state exists that satisfies all constraints) or UNSATISFIABLE 
(when no valid state can satisfy all constraints simultaneously).

In the following subsections, we explain each step in detail using our Software 
System example from Figure \ref{fig:class_diagram_software_system}.


\subsection{Step 1: Transforming the Application Model into a Filmstrip Model}

\hspace{1cm} The first step in our verification approach applies the filmstripping technique (described in Section~\ref{subsec:filmstripping}) to transform our Software System model into a static representation. Rather than repeating the general transformation process, we focus here on the specific application to our example and how it enables subsequent verification steps.

For our Software System model from Figure \ref{fig:class_diagram_software_system}, the filmstrip transformation preserves the original classes (\texttt{System} and \texttt{Application}) and their associations while introducing the filmstrip infrastructure. The four operations in our model—\texttt{load(app:~Application)}, \texttt{install()}, \texttt{run(app:~Application)}, and \texttt{stop(app:~Application)}—are each transformed into concrete \texttt{OperationCall} subclasses that capture their specific parameters and context.

The critical aspect of this transformation is how it represents temporal behavior through structural relationships. Each snapshot in the resulting filmstrip model corresponds to a distinct point in time, with operation calls connecting these snapshots to form execution sequences. This structural representation allows us to track how object states change over time, which is essential for verifying temporal properties.

The transformation of operation contracts is particularly important for our verification approach. Consider the pre- and postconditions for the \texttt{load} operation shown in Listing~\ref{lst:pre_post_load}. These conditions are transformed into invariants in the filmstrip model, as shown in Listing~\ref{lst:invariants_load_SystemOpC}. For example, the postcondition \texttt{loaded} becomes an invariant that navigates between pre- and post-operation states using \texttt{succSystem} and \texttt{predSystem} associations.

The resulting filmstrip model was previously illustrated in Figure \ref{fig:filmstrip_model} in Chapter 1, showing how the original application model is extended with filmstrip-specific elements. This structural representation of system behavior forms the foundation for the next steps in our verification approach, allowing us to express and check temporal properties as static constraints over the filmstrip model.

\begin{lstlisting}[
    style=toclstyle, 
    caption={Pre and post conditions for load operation.}, 
    label={lst:pre_post_load}
]
context System::load(app: Application)
    pre notLoaded: 
        not self.loadedApps->includes(app) and
        not self.installedApps->includes(app) and
        not self.runningApps->includes(app)
    pre enoughMemory: 
        self.freeMemory >= app.size
    post loaded: 
        self.loadedApps = self.loadedApps@pre->including(app)
    post reduceMemory: 
        self.freeMemory = self.freeMemory@pre - app.size
\end{lstlisting}

\begin{lstlisting}[
    style=toclstyle, 
    caption={Invariants for load\_SystemOpC}, 
    label={lst:invariants_load_SystemOpC}
]
context load_SystemOpC 
inv pre_notLoaded:
    not aSelf.loadedApps->includes(app) and 
    not aSelf.installedApps->includes(app) and 
    not aSelf.runningApps->includes(app)

context load_SystemOpC 
inv pre_enoughMemory:
    aSelf.freeMemory >= app.size

context load_SystemOpC 
inv post_loaded:
    aSelf.succSystem.loadedApps = 
    aSelf.succSystem.predSystem.loadedApps->collectNested( a1:Application | 
        a1.succApplication 
    )->asSet()->including(app.succApplication)

context load_SystemOpC 
inv post_reduceMemory:
    aSelf.succSystem.freeMemory = 
    aSelf.succSystem.predSystem.freeMemory - app.succApplication.size
\end{lstlisting}


\subsection{Step 2: Translating TOCL+ Properties into OCL Expressions}

\hspace{1cm} After transforming the application model into a filmstrip model, the second step of our verification approach involves translating TOCL+ temporal properties into equivalent OCL constraints. These constraints must be expressed in terms of the filmstrip model structure created in Step 1, allowing them to be verified using standard OCL tools.

The translation process begins with temporal properties specified in TOCL+ for the original Software System model. Each TOCL+ property is systematically transformed into an OCL constraint that navigates through the filmstrip structure of snapshots and operation calls. This transformation preserves the semantic meaning of the original temporal specifications while expressing them through the structural elements of the filmstrip model.

Listing \ref{lst:tocl+} shows the original TOCL+ properties specified for our Software System model, including safety and liveness properties. As an example of the translation process, Listing \ref{lst:ocl_liveness} presents the OCL translation for the liveness property, demonstrating how temporal requirements are mapped to structural constraints within the filmstrip framework. The translation uses snapshot navigation and operation call existence checks to capture the temporal semantics of the original property.

The resulting OCL constraints serve as the input for the verification step that follows, where they will be evaluated against potential system states to determine if the model satisfies the specified temporal properties.

\begin{lstlisting}[
    style=toclstyle, 
    caption={OCL translation of liveness property.}, 
    label={lst:ocl_liveness}
]
context System
inv liveness:
    self.loadedApps->notEmpty() implies
    self.loadedApps->forAll(app |
        (let CS:Snapshot = self.snapshotSystem in 
        Set{CS}->closure(s | s.succ())->excluding(null)->exists(s | 
            install_SystemOpC.allInstances()->exists(op | op.succ() = s)
        ))
    )
\end{lstlisting}

\subsection{Step 3: Verifying the translated OCL expressions}

Our approach uses the USE Model Validator \cite{USE_Validator} to produce
scenarios (e.g., instances of the filmstrip model) and check if there exists a
solution that satisfies the OCL properties generated in Step 2. The Model Validator 
uses boolean satisfiability (SAT) solver to perform the analysis. Before the 
analysis process begins, the modeler must configure the search space for the analysis.
The configurations are written in text files with the extension .properties. 
In the configuration file, a lower and upper limit can be specified for each 
configurable base type (Integer, Real, String), each class, each attribute of a 
class, and associations, which specifies how many instances should be there in the 
object diagram. As such, the Model Validator enumerates all possible scenarios
within the defined scopes and checks them against a given property. 